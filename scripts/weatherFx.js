/*
Copyright (c) 2023 BlackStripedOne
This software is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.

You may obtain a copy of the License at:
https://creativecommons.org/licenses/by-sa/4.0/legalcode

Code written by BlackStripedOne can be found at:
https://github.com/BlackStripedOne

This source is part of the SceneWeather module for FoundryVTT virtual tabletop game that can be found at:
https://github.com/BlackStripedOne/fvtt-scene-weather

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.
*/

import { Logger, Utils } from './utils.js'

/**
 * A particle effect class that generates an array of emitter configurations based on the generators in the game's
 * scene weather object. It also provides methods to update and play the particle effect, as well as to fade it out
 * gracefully.
 * 
 * @see https://foundryvtt.com/api/classes/client.ParticleEffect.html
 * @see https://github.com/pixijs/particle-emitter/blob/d82acc7d920519fac3f4f55b7cb2b6236e31335e/src/Particle.ts
 * 
 * @extends ParticleEffect
 */
export class WeatherEffect extends ParticleEffect {

  /**
   * A human-readable label for the weather effect. This can be a localization string
   */
  static label = "sceneweather.fxname"

  /**
   * Returns an array of emitter configurations generated by the generators in the game's scene weather object
   * for the given model data.
   *
   * @param modelData - The model data for which to generate emitter configurations.
   * @returns An array of emitter configurations generated by the generators in the game's scene weather object.
   */
  static _getFxEmittersForModel(modelData) {
    // TODO check for correct modelData content
    let emitterConfigs = []
    game.sceneWeather.generators.forEach(generator => {
      let config = generator.getEmitter(modelData)
      if (config) {
        emitterConfigs.push(config)
      }
    })
    Logger.debug('WeatherEffect._getFxEmittersForModel()', { 'model': modelData, 'gen': game.sceneWeather.generators, 'emitters': emitterConfigs })
    return emitterConfigs
  }

  /**
   * Updates the array of emitter configurations to ensure that the total number of particles
   * across all configurations does not exceed a maximum number of particles.
   * 
   * Perfomance using imperative for then declarative reduce, map or forEach.
   * 
   * @param emitterConfigs - An array of emitter configurations.
   * @param maxParticles - The maximum number of particles allowed.
   * @returns An array of updated emitter configurations.
   */
  static _equalizeMaxParticles(emitterConfigs, maxParticles) {
    let totalParticles = 0
    let totalWeights = 0

    // Calculate the total number of particles and the total weight of all emitter configurations.
    for (let i = 0; i < emitterConfigs.length; i++) {
      const emitterConfig = emitterConfigs[i]
      totalParticles += emitterConfig.maxParticles
      totalWeights += emitterConfig.weight
    }

    // If the total number of particles is less than or equal to the maximum number of particles,
    // return the input emitter configurations.
    if (totalParticles <= maxParticles) {
      return emitterConfigs
    }

    // Calculate the reduction factor for the number of particles based on the weight of each emitter configuration.
    let reductionFactor = 0
    for (let i = 0; i < emitterConfigs.length; i++) {
      const emitterConfig = emitterConfigs[i]
      reductionFactor += (emitterConfig.maxParticles * (emitterConfig.weight / totalWeights))
    }
    reductionFactor = maxParticles / reductionFactor

    // Update the maxParticles property of each emitter configuration based on the reduction factor and weight.
    for (let i = 0; i < emitterConfigs.length; i++) {
      const emitterConfig = emitterConfigs[i]
      emitterConfig.maxParticles *= reductionFactor * (emitterConfig.weight / totalWeights)
    }
    Logger.debug('WeatherEffect._equalizeMaxParticles()', { 'totalParticles': totalParticles, 'maxParticles': maxParticles })
    return emitterConfigs
  }

  /**
   * Begin animation for the configured emitters
   * 
   * @param {*} object may contain optional bool easeIn for making the effect slowly ease in
   */
  play({ easeIn = true } = {}) {
    if (!easeIn) {
      this.emitters.forEach((emitter) => {
        emitter.autoUpdate = false
        emitter.emit = true
        emitter.update(emitter.maxLifetime)
        emitter.autoUpdate = true
      })
    }
    super.play()
  }

  /**
   * Get the particle emitters which should be active for this particle effect
   * 
   * @param {object} options emitter options
   * @returns Emitter[]
   */
  getParticleEmitters(options = {}) {
    Logger.debug('WeatherEffect.getParticleEmitters(...)', { 'options': options })
    // TODO only when user has weather effects allowed via settings

    if (options['data'] === undefined || options.data['model'] === undefined) {
      Logger.debug('WeatherEffect.getParticleEmitters() no model data contained, no emitters.')
      return []
    }

    const emitterConfigs = WeatherEffect._getFxEmittersForModel(options.data.model)//  game.sceneWeather.get().getSceneWeatherFxEmitters()
    // TODO scale particle amount
    const maxParticles = Utils.getSetting('maxParticles', 3200) // Default 3200
    WeatherEffect._equalizeMaxParticles(emitterConfigs, maxParticles)

    let emitters = []
    // TODO order of effects ( z-ordering )
    emitterConfigs.forEach(emitterConfig => {
      emitters.push(this.createEmitter(emitterConfig))
    })
    return emitters
  }

  /**
   * Fade this effect out for a given amount of second before stopping it
   * 
   * @param {object} may contain the optional number gracePeriod in seconds to give the emitter time to fade out
   * @returns {Promise<void>} a promise that resolves as soon as this emitter has finished
   */
  async softStop({ gracePeriod } = {}) {
    const emitterPromises = this.emitters.map(
      (emitter) =>
        new Promise((resolve) => {
          // Decimate active particles
          let particle = emitter._activeParticlesFirst
          while (particle != null) {
            const timeLeft = gracePeriod
            const currentTime = Math.max(particle.age, particle.maxLife - timeLeft)
            particle.age = currentTime
            particle.agePercent = particle.age * particle.oneOverLife
            particle = particle.next
          }
          // See https://pixijs.io/particle-emitter/docs/classes/Emitter.html#playOnceAndDestroy          
          emitter.emitterLifetime = 0
          emitter.playOnceAndDestroy(() => {
            resolve()
          })
        })
    )
    const promises = [Promise.all(emitterPromises)]
    if (gracePeriod !== undefined) {
      promises.push(
        new Promise(
          (resolve) => setTimeout(resolve, gracePeriod * 1000)
        ).then(
          this.destroy.bind(this)
        )
      )
    }
    await Promise.race(promises)
    this.stop()
  }
}
